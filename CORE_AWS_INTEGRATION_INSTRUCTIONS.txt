SIMPLIFIED AWS INTEGRATION INSTRUCTIONS - CORE SERVICES ONLY
=============================================================

This file provides streamlined instructions for integrating only the essential AWS services needed for the Lavatory Finder app to function.

## CORE AWS SERVICES (5 TOTAL)
1. Amazon Cognito - User authentication
2. Amazon DynamoDB - Data storage  
3. Amazon API Gateway - REST API
4. AWS Lambda - Serverless functions
5. Amazon S3 - Image storage

## REMOVED SERVICES (COST OPTIMIZATION)
❌ Amazon CloudFront (use direct S3 URLs)
❌ Amazon Pinpoint (basic analytics only)
❌ AWS AppSync (use REST API)
❌ Amazon Location Service (basic GPS)
❌ Amazon Rekognition (manual moderation)

## QUICK SETUP (30 MINUTES)

### Step 1: Install AWS Amplify CLI
```bash
npm install -g @aws-amplify/cli
amplify configure
```

### Step 2: Initialize Project
```bash
cd /Users/yifanfang/Documents/GitHub/AWS_Summit_Hack
amplify init
# Follow prompts: name=lavatory-finder, env=dev, editor=code
```

### Step 3: Add Core Services
```bash
# Authentication
amplify add auth
# Select: Default configuration with Social Provider (Federated Identities)

# API
amplify add api
# Select: REST, Create new Lambda function, Serverless express function

# Storage
amplify add storage
# Select: Content (Images, audio, video, etc.)
```

### Step 4: Deploy
```bash
amplify push
```

## CODE REPLACEMENTS

### 1. Replace Mock Data Functions

**FIND THIS PATTERN:**
```typescript
// AWS INTEGRATION PLACEHOLDER: Replace with actual AWS API calls
const fetchNearbyServices = async (latitude: number, longitude: number): Promise<ServiceType[]> => {
  // TODO: Replace with actual AWS API call
  // Mock data for development - REMOVE when AWS integration is complete
  return [
    // ... mock data
  ];
};
```

**REPLACE WITH:**
```typescript
import { apiService } from '../services/api';

const fetchNearbyServices = async (latitude: number, longitude: number): Promise<ServiceType[]> => {
  return await apiService.getNearbyServices(latitude, longitude);
};
```

### 2. Replace Mock Review Functions

**FIND THIS PATTERN:**
```typescript
const fetchServiceReviews = async (serviceId: string): Promise<Review[]> => {
  // TODO: Replace with actual AWS API call
  // Mock reviews for development - REMOVE when AWS integration is complete
  return [
    // ... mock reviews
  ];
};
```

**REPLACE WITH:**
```typescript
import { apiService } from '../services/api';

const fetchServiceReviews = async (serviceId: string): Promise<Review[]> => {
  return await apiService.getServiceReviews(serviceId);
};
```

### 3. Replace Mock Ad Functions

**FIND THIS PATTERN:**
```typescript
// Mock ad data for development - REMOVE when AWS integration is complete
const mockAdContent = {
  id: adId,
  title: 'Premium Cleaning Services',
  // ... mock ad data
};
```

**REPLACE WITH:**
```typescript
// Simple ad implementation - can be enhanced later
const fetchAdContent = async (adId: string): Promise<AdContent | null> => {
  // For now, return null to hide ads
  // Can integrate with ad network later
  return null;
};
```

## LAMBDA FUNCTIONS (3 TOTAL)

### 1. services.js - Main services handler
```javascript
const AWS = require('aws-sdk');
const dynamodb = new AWS.DynamoDB.DocumentClient();

exports.handler = async (event) => {
    if (event.httpMethod === 'GET') {
        return await getNearbyServices(event);
    }
    return {
        statusCode: 405,
        body: JSON.stringify({ error: 'Method not allowed' })
    };
};

async function getNearbyServices(event) {
    const { lat, lng, radius = 1 } = event.queryStringParameters || {};
    
    // Simple scan - can be optimized with GSI later
    const params = {
        TableName: 'lavatory-services'
    };
    
    const result = await dynamodb.scan(params).promise();
    
    // Filter by distance (basic implementation)
    const nearbyServices = result.Items.filter(service => {
        const distance = calculateDistance(lat, lng, service.latitude, service.longitude);
        return distance <= radius;
    });
    
    return {
        statusCode: 200,
        headers: {
            'Access-Control-Allow-Origin': '*',
            'Content-Type': 'application/json'
        },
        body: JSON.stringify({ services: nearbyServices })
    };
}

function calculateDistance(lat1, lng1, lat2, lng2) {
    // Simple distance calculation
    return Math.sqrt(Math.pow(lat1 - lat2, 2) + Math.pow(lng1 - lng2, 2)) * 111;
}
```

### 2. reviews.js - Reviews handler
```javascript
const AWS = require('aws-sdk');
const dynamodb = new AWS.DynamoDB.DocumentClient();

exports.handler = async (event) => {
    const { httpMethod, pathParameters, body } = event;
    
    if (httpMethod === 'GET') {
        return await getReviews(pathParameters.serviceId);
    } else if (httpMethod === 'POST') {
        return await createReview(JSON.parse(body));
    }
    
    return { statusCode: 405, body: JSON.stringify({ error: 'Method not allowed' }) };
};

async function getReviews(serviceId) {
    const params = {
        TableName: 'lavatory-reviews',
        FilterExpression: 'serviceId = :serviceId',
        ExpressionAttributeValues: { ':serviceId': serviceId }
    };
    
    const result = await dynamodb.scan(params).promise();
    
    return {
        statusCode: 200,
        headers: { 'Access-Control-Allow-Origin': '*', 'Content-Type': 'application/json' },
        body: JSON.stringify({ reviews: result.Items })
    };
}

async function createReview(reviewData) {
    const review = {
        ...reviewData,
        id: Date.now().toString(),
        createdAt: new Date().toISOString()
    };
    
    await dynamodb.put({
        TableName: 'lavatory-reviews',
        Item: review
    }).promise();
    
    return {
        statusCode: 201,
        headers: { 'Access-Control-Allow-Origin': '*', 'Content-Type': 'application/json' },
        body: JSON.stringify({ review })
    };
}
```

### 3. images.js - Image upload handler
```javascript
const AWS = require('aws-sdk');
const s3 = new AWS.S3();

exports.handler = async (event) => {
    const { serviceId, image, type } = JSON.parse(event.body);
    
    const imageBuffer = Buffer.from(image, 'base64');
    const fileName = `${type}/${serviceId}/${Date.now()}.jpg`;
    
    await s3.putObject({
        Bucket: process.env.STORAGE_BUCKET_NAME,
        Key: fileName,
        Body: imageBuffer,
        ContentType: 'image/jpeg'
    }).promise();
    
    const imageUrl = `https://${process.env.STORAGE_BUCKET_NAME}.s3.amazonaws.com/${fileName}`;
    
    return {
        statusCode: 200,
        headers: { 'Access-Control-Allow-Origin': '*', 'Content-Type': 'application/json' },
        body: JSON.stringify({ imageUrl })
    };
};
```

## DYNAMODB TABLES (2 TOTAL)

### 1. lavatory-services
```json
{
  "TableName": "lavatory-services",
  "KeySchema": [
    {"AttributeName": "id", "KeyType": "HASH"}
  ],
  "AttributeDefinitions": [
    {"AttributeName": "id", "AttributeType": "S"}
  ],
  "BillingMode": "PAY_PER_REQUEST"
}
```

### 2. lavatory-reviews
```json
{
  "TableName": "lavatory-reviews",
  "KeySchema": [
    {"AttributeName": "id", "KeyType": "HASH"}
  ],
  "AttributeDefinitions": [
    {"AttributeName": "id", "AttributeType": "S"}
  ],
  "BillingMode": "PAY_PER_REQUEST"
}
```

## SAMPLE DATA SETUP

### Add Sample Services
```javascript
// Run this in AWS Console or Lambda function
const sampleServices = [
  {
    id: '1',
    name: 'City Mall Restroom',
    type: 'bathroom',
    rating: 4.2,
    reviewCount: 156,
    latitude: 37.7749,
    longitude: -122.4194,
    address: '123 Main St, Downtown',
    amenities: ['wheelchair', 'baby-changing'],
    isOpen: true,
    createdAt: new Date().toISOString()
  },
  {
    id: '2',
    name: 'Central Park Water Fountain',
    type: 'water_fountain',
    rating: 4.5,
    reviewCount: 89,
    latitude: 37.7849,
    longitude: -122.4094,
    address: '456 Park Ave',
    amenities: ['filtered-water'],
    isOpen: true,
    createdAt: new Date().toISOString()
  }
];

// Insert into DynamoDB
for (const service of sampleServices) {
  await dynamodb.put({
    TableName: 'lavatory-services',
    Item: service
  }).promise();
}
```

## COST ESTIMATION (MONTHLY)

| Service | Usage | Cost |
|---------|-------|------|
| Cognito | 1,000 users | $0.0055 |
| DynamoDB | 100,000 operations | $0.25 |
| API Gateway | 100,000 requests | $3.50 |
| Lambda | 100,000 invocations | $0.20 |
| S3 | 1GB storage | $0.023 |
| **TOTAL** | | **~$4/month** |

## TESTING CHECKLIST

- [ ] User can sign up/sign in with Cognito
- [ ] App fetches real services from DynamoDB
- [ ] Reviews can be created and retrieved
- [ ] Images can be uploaded to S3
- [ ] All API endpoints respond correctly
- [ ] Error handling works properly
- [ ] App works without internet (graceful degradation)

## DEPLOYMENT COMMANDS

```bash
# Deploy all services
amplify push

# Deploy specific service
amplify push --category auth
amplify push --category api
amplify push --category storage

# Check status
amplify status

# View logs
amplify logs
```

## TROUBLESHOOTING

### Common Issues:
1. **CORS errors**: Add CORS headers to Lambda responses
2. **Permission errors**: Check IAM roles and policies
3. **Network errors**: Verify API Gateway configuration
4. **Auth errors**: Check Cognito configuration

### Debug Commands:
```bash
# View API Gateway logs
amplify logs api

# View Lambda logs  
amplify logs function

# Test API endpoints
curl -X GET "https://your-api-id.execute-api.region.amazonaws.com/dev/services?lat=37.7749&lng=-122.4194"
```

## NEXT STEPS AFTER CORE INTEGRATION

1. **Add real data** to DynamoDB tables
2. **Test all functionality** with real AWS services
3. **Optimize performance** (add indexes, caching)
4. **Add monitoring** (CloudWatch alarms)
5. **Scale up** (add more services as needed)

This simplified approach gives you a **fully functional app** with minimal complexity and costs!
